<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Statistics Parser</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        .filter-group {
    margin-bottom: 15px;
}

.search-input {
    padding: 8px 12px;
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    margin-bottom: 10px;
    display: block !important;
    visibility: visible !important;
}

.search-input:focus {
    outline: none;
    border-color: #80bdff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

#playerSearchContainer {
    display: block !important;
    visibility: visible !important;
}
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .description {
            text-align: center;
            margin-bottom: 30px;
            color: #666;
        }
        
        .upload-area {
            border: 2px dashed #ccc;
            padding: 30px;
            text-align: center;
            margin: 20px 0;
            border-radius: 8px;
            transition: border-color 0.3s, background-color 0.3s;
            background-color: white;
        }
        
        .upload-area:hover {
            border-color: #4CAF50;
            background-color: #f9f9f9;
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }
        
        .search-container {
            margin: 20px 0;
            text-align: center;
        }
        #item-search {
            padding: 8px;
            width: 300px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        #fileInput {
            display: none;
        }
        
        .upload-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #45a049;
        }
        
        #fileInfo {
            margin-top: 10px;
            color: #666;
        }
        
        .loading {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        .error {
            color: #dc3545;
            padding: 15px;
            background-color: #f8d7da;
            border-radius: 4px;
            margin: 15px 0;
            border: 1px solid #f5c6cb;
        }
        
        .filters {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .filter-group {
            flex: 1;
            min-width: 200px;
        }
        
        .filter-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .category-filter, .sort-select {
            width: 100%;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        
        /* è¡¨æ ¼æ ·å¼ - å“åº”å¼è®¾è®¡ */
        .stats-container {
            margin: 20px 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
        }
        
        .stats-table th, 
        .stats-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .stats-table th {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        
        .stats-table tr:hover {
            background-color: #f9f9f9;
        }
        
        /* å“åº”å¼æ ·å¼ */
        @media (max-width: 768px) {
            /* åœ¨ä¸­ç­‰å±å¹•ä¸Šå˜ä¸ºä¸¤åˆ—å¸ƒå±€ */
            .stats-table thead {
                display: none;
            }
            
            .stats-table tr {
                display: block;
                margin-bottom: 15px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            
            .stats-table td {
                display: block;
                text-align: right;
                position: relative;
                padding-left: 50%;
            }
            
            .stats-table td::before {
                content: attr(data-label);
                position: absolute;
                left: 0;
                width: 50%;
                padding-left: 12px;
                text-align: left;
                font-weight: bold;
            }
            
            /* éšè—ç±»åˆ«åˆ—ï¼Œå°†ç±»åˆ«ä½œä¸ºæ ‡é¢˜æ˜¾ç¤º */
            .stats-table td:nth-child(1) {
                background-color: #f0f0f0;
                font-weight: bold;
                text-align: center;
                padding: 12px;
            }
            
            .stats-table td:nth-child(1)::before {
                display: none;
            }
            
            .stats-table td:nth-child(2) {
                border-bottom: 1px solid #eee;
            }
        }
        
        @media (max-width: 480px) {
            /* åœ¨å°å±å¹•ä¸Šå˜ä¸ºå•åˆ—å¸ƒå±€ */
            .stats-table td {
                display: block;
                text-align: left;
                padding: 8px 12px;
                position: relative;
            }
            
            .stats-table td::before {
                display: block;
                width: 100%;
                padding-left: 0;
                margin-bottom: 4px;
            }
            
            .stats-table td:nth-child(1) {
                padding: 12px;
            }
            
            .stats-table td:nth-child(2),
            .stats-table td:nth-child(3) {
                padding-left: 12px;
            }
        }
    </style>
    <script src="https://s4.zstatic.net/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div class="container">
    <div style="position: relative;">
    <h1>Minecraft Statistics Parser</h1>
    <button id="languageButton" style="position: absolute; top: 0; right: 0; background-color: #28a745; color: white; width: 30px; height: 30px; border-radius: 50%; border: none; font-size: 18px; cursor: pointer; margin-right: 70px; text-align: center; line-height: 30px;" onclick="window.location.href='../index.html'">ğŸŒ</button>
    <button id="helpButton" style="position: absolute; top: 0; right: 0; background-color: #007bff; color: white; width: 30px; height: 30px; border-radius: 50%; border: none; font-size: 18px; cursor: pointer; margin-right: 35px;">?</button>
    <button id="changelogButton" style="position: absolute; top: 0; right: 0; background-color: #ffc107; color: white; width: 30px; height: 30px; border-radius: 50%; border: none; font-size: 18px; cursor: pointer;">!</button>
</div>
    <p class="description">Upload your Minecraft statistics file to view detailed player statistics.</p>

        <div class="upload-area">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Select File</button>
            <input type="file" id="fileInput" accept=".json,.zip,.lang">
            <p id="fileInfo">No file selected</p>
        </div>

        <div id="loading" class="loading" style="display: none;">Parsing data...</div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="filters" class="filters" style="display: none;">
            <!-- æ·»åŠ æœç´¢æ¡† -->
            <div class="filter-group" id="playerSearchContainer">
                <label for="playerSearch" class="filter-label">Search Player:</label>
                <input type="text" id="playerSearch" class="search-input" placeholder="Enter player name or UUID">
            </div>
            
            <!-- ç©å®¶é€‰æ‹©å°†åœ¨è¿™é‡ŒåŠ¨æ€æ’å…¥ -->
            
            <div class="filter-group">
                <label for="categoryFilter" class="filter-label">Filter by Category:</label>
                <select id="categoryFilter" class="category-filter">
                    <option value="all">All Categories</option>
                    <!-- ç±»åˆ«å°†åŠ¨æ€ç”Ÿæˆ -->
                </select>
            </div>
            
            <div class="filter-group">
                <label for="sortSelect" class="filter-label">Sort by:</label>
                <select id="sortSelect" class="sort-select">
                    <option value="category">Category</option>
                    <option value="count-asc">Count (Ascending)</option>
                    <option value="count-desc">Count (Descending)</option>
                </select>
            </div>
        </div>

        <div class="stats-container">
            <div class="search-container" style="display: none;">
                <input type="text" id="item-search" placeholder="Search for items...">
            </div>
            <div id="tableContainer"></div>
        </div>
    </div>

    <script>
        // å­˜å‚¨ç¿»è¯‘æ•°æ®
        let translations = {
            category: {},
            item: {}
        };
        
        // æ·»åŠ æ ‡å¿—å˜é‡è¡¨ç¤ºæ˜¯å¦å·²ä¸Šä¼ ç¿»è¯‘æ–‡ä»¶
        let translationFileUploaded = false;
        
        // å­˜å‚¨ç”¨æˆ·ç¼“å­˜æ•°æ® - æ–°å¢
        let userCache = {};

        // åœ¨æ ‡ç­¾å†…ï¼ŒuserCacheå˜é‡åæ·»åŠ 
        // å­˜å‚¨æ‰€æœ‰ç©å®¶çš„ç»Ÿè®¡æ•°æ®
        let allPlayersStats = {};
        // å­˜å‚¨UUIDåˆ°æ–‡ä»¶åçš„æ˜ å°„
        let uuidToFilename = {};

        // ä¿®æ”¹æ–‡ä»¶ä¸Šä¼ å¤„ç†å‡½æ•°
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            handleFileUpload(file);
        });

        // æ·»åŠ æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½
        const uploadArea = document.querySelector('.upload-area');

        // é˜»æ­¢æµè§ˆå™¨é»˜è®¤æ‹–æ”¾è¡Œä¸º
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // æ·»åŠ æ‹–æ‹½è§†è§‰åé¦ˆ
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            uploadArea.classList.add('dragover');
        }

        function unhighlight() {
            uploadArea.classList.remove('dragover');
        }

        // å¤„ç†æ‹–æ”¾æ–‡ä»¶
        uploadArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const file = dt.files[0];
            if (file) {
                handleFileUpload(file);
            }
        }

        // é‡æ„æ–‡ä»¶å¤„ç†é€»è¾‘ä¸ºé€šç”¨å‡½æ•°
        function handleFileUpload(file) {
            // Show file name
            document.getElementById('fileInfo').textContent = `Selected: ${file.name}`;

            // Show loading state
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('tableContainer').innerHTML = '';
            document.getElementById('filters').style.display = 'none';
            
            // éšè—ç‰©å“æœç´¢æ¡†
            const searchContainer = document.querySelector('.search-container');
            if (searchContainer) {
                searchContainer.style.display = 'none';
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºç¿»è¯‘æ–‡ä»¶
    if (file.name.toLowerCase().endsWith('.lang') || 
        (file.name.toLowerCase().endsWith('.json') && 
         file.name.toLowerCase().includes('translation'))) {
        handleTranslationFile(file);
        return;
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºZIPæ–‡ä»¶
    if (file.name.toLowerCase().endsWith('.zip')) {
        handleZipFile(file);
    } else if (file.name.toLowerCase() === 'usercache.json') {
        // å•ç‹¬å¤„ç†usercache.jsonæ–‡ä»¶
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                document.getElementById('loading').style.display = 'none';
                const success = processUserCache(e.target.result);
                if (success) {
                    document.getElementById('error').textContent = 'User cache data loaded successfully! Now you can upload Minecraft stats files or ZIP archives.';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').style.backgroundColor = '#d4edda';
                    document.getElementById('error').style.color = '#155724';
                    document.getElementById('error').style.borderColor = '#c3e6cb';
                    // å¦‚æœå·²æœ‰ç©å®¶æ•°æ®ï¼Œæ›´æ–°ç©å®¶åç§°
                    updatePlayerSelect();
                } else {
                    document.getElementById('error').textContent = 'Failed to parse usercache.json file. Please check the file format.';
                    document.getElementById('error').style.display = 'block';
                }
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').textContent = `Failed to parse file: ${error.message}`;
                document.getElementById('error').style.display = 'block';
            }
        };
        reader.readAsText(file);
    } else {
        // å¤„ç†å•ä¸ªç»Ÿè®¡æ•°æ®æ–‡ä»¶
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                document.getElementById('loading').style.display = 'none';
                // å¤„ç†æ™®é€šç»Ÿè®¡æ•°æ®æ–‡ä»¶
                const processedData = processMinecraftStats(e.target.result);

                if (processedData && processedData.length > 0) {
                    // å°è¯•ä»æ–‡ä»¶åæå–UUID
                    const fileName = file.name;
                    const uuidMatch = fileName.match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);
                    let playerName = 'Unknown Player';
                    let uuid = null;

                    if (uuidMatch && uuidMatch[1]) {
                        uuid = uuidMatch[1];
                        playerName = getPlayerName(uuid);
                        // å­˜å‚¨ç©å®¶æ•°æ®
                        allPlayersStats[uuid] = processedData;
                        uuidToFilename[uuid] = fileName;
                    }

                    // åœ¨è¡¨æ ¼ä¸Šæ–¹æ˜¾ç¤ºç©å®¶åç§°
                    const tableContainer = document.getElementById('tableContainer');
                    tableContainer.innerHTML = `<h2>ç©å®¶: ${playerName}</h2>`;

                    displayAsTable(processedData);
                    // æ›´æ–°ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
                    updatePlayerSelect();
                } else {
                    document.getElementById('error').textContent = 'No valid data found. Please check the file format.';
                    document.getElementById('error').style.display = 'block';
                }
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').textContent = `Failed to parse file: ${error.message}`;
                document.getElementById('error').style.display = 'block';
            }
        };
        reader.readAsText(file);
    }
        }

        // æ·»åŠ å¤„ç†ç¿»è¯‘æ–‡ä»¶çš„å‡½æ•°
        function handleTranslationFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    document.getElementById('loading').style.display = 'none';
                    let translationData;

                    if (file.name.toLowerCase().endsWith('.json')) {
                        // å¤„ç†JSONæ ¼å¼çš„ç¿»è¯‘æ–‡ä»¶
                        translationData = JSON.parse(e.target.result);
                    } else if (file.name.toLowerCase().endsWith('.lang')) {
                        // å¤„ç†Minecraftçš„.langæ ¼å¼ç¿»è¯‘æ–‡ä»¶
                        translationData = parseLangFile(e.target.result);
                    }

                    if (translationData) {
                        translations = translationData;
                        translationFileUploaded = true;
                        console.log('Translation file loaded successfully', translations);
                        document.getElementById('error').textContent = 'ç¿»è¯‘æ–‡ä»¶åŠ è½½æˆåŠŸï¼';
                        document.getElementById('error').style.display = 'block';
                        document.getElementById('error').style.backgroundColor = '#d4edda';
                        document.getElementById('error').style.color = '#155724';
                        document.getElementById('error').style.borderColor = '#c3e6cb';

                        // å¦‚æœå·²æœ‰ç©å®¶æ•°æ®ï¼Œé‡æ–°å¤„ç†å¹¶æ˜¾ç¤º
                        if (Object.keys(allPlayersStats).length > 0) {
                            const firstUuid = Object.keys(allPlayersStats)[0];
                            showPlayerStats(firstUuid);
                        }
                    }
                } catch (error) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').textContent = `è§£æç¿»è¯‘æ–‡ä»¶æ—¶å‡ºé”™: ${error.message}`;
                    document.getElementById('error').style.display = 'block';
                }
            };
            reader.readAsText(file);
        }

        // æ·»åŠ è§£æ.langæ–‡ä»¶çš„å‡½æ•°
        function parseLangFile(content) {
            const lines = content.split('\n');
            const result = {
                category: {},
                item: {}
            };

            lines.forEach(line => {
                // è·³è¿‡æ³¨é‡Šå’Œç©ºè¡Œ
                if (line.startsWith('#') || line.trim() === '') return;

                const parts = line.split('=');
                if (parts.length !== 2) return;

                const key = parts[0].trim();
                const value = parts[1].trim();

                // å°è¯•è¯†åˆ«ç±»åˆ«å’Œç‰©å“
                if (key.startsWith('stat.category.')) {
                    const category = key.replace('stat.category.', '');
                    result.category[category] = value;
                } else if (key.startsWith('item.minecraft.')) {
                    const item = key.replace('item.minecraft.', '');
                    result.item[item] = value;
                } else if (key.startsWith('block.minecraft.')) {
                    const block = key.replace('block.minecraft.', '');
                    result.item[block] = value;
                }
            });

            return result;
        }

        // æ·»åŠ å¤„ç†ZIPæ–‡ä»¶çš„å‡½æ•°
        function handleZipFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                JSZip.loadAsync(e.target.result)
                    .then(function(zip) {
                        // å­˜å‚¨è§£æçš„æ–‡ä»¶æ•°
                        let processedFiles = 0;
                        let totalFiles = 0;
                        let hasUserCache = false;

                        // å…ˆæ£€æŸ¥æ–‡ä»¶æ€»æ•°
                        zip.forEach(function(relativePath, zipEntry) {
                            totalFiles++;
                        });

                        // éå†ZIPä¸­çš„æ‰€æœ‰æ–‡ä»¶
                        zip.forEach(function(relativePath, zipEntry) {
                            if (zipEntry.name.toLowerCase() === 'usercache.json') {
                                // å¤„ç†usercache.json
                                zipEntry.async('text')
                                    .then(function(content) {
                                        processUserCache(content);
                                        hasUserCache = true;
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    })
                                    .catch(function(error) {
                                        console.error('Failed to read usercache.json:', error);
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    });
                            } else if (zipEntry.name.toLowerCase().endsWith('.json')) {
                                // å¤„ç†ç»Ÿè®¡æ•°æ®æ–‡ä»¶
                                zipEntry.async('text')
                                    .then(function(content) {
                                        const fileName = zipEntry.name;
                                        const uuidMatch = fileName.match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);

                                        if (uuidMatch && uuidMatch[1]) {
                                            const uuid = uuidMatch[1];
                                            const processedData = processMinecraftStats(content);
                                            if (processedData && processedData.length > 0) {
                                                allPlayersStats[uuid] = processedData;
                                                uuidToFilename[uuid] = fileName;
                                            }
                                        }
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    })
                                    .catch(function(error) {
                                        console.error('Failed to read JSON file:', error);
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    });
                            } else {
                                processedFiles++;
                                checkIfAllFilesProcessed();
                            }
                        });

                        function checkIfAllFilesProcessed() {
                            if (processedFiles === totalFiles) {
                                document.getElementById('loading').style.display = 'none';
                                
                                if (Object.keys(allPlayersStats).length === 0) {
                                    document.getElementById('error').textContent = 'No valid player statistics files found.';
                                    document.getElementById('error').style.display = 'block';
                                } else {
                                    // æ›´æ–°ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
                                    updatePlayerSelect();

                                    if (hasUserCache) {
                                        document.getElementById('error').textContent = 'ZIP file parsed successfully! Data of ' + Object.keys(allPlayersStats).length + ' players has been loaded.';
                                        document.getElementById('error').style.display = 'block';
                                        document.getElementById('error').style.backgroundColor = '#d4edda';
                                        document.getElementById('error').style.color = '#155724';
                                        document.getElementById('error').style.borderColor = '#c3e6cb';
                                    } else {
                                        document.getElementById('error').textContent = 'ZIP file parsed successfully, but no usercache.json file found. Player names will be displayed as UUIDs.';
                                        document.getElementById('error').style.display = 'block';
                                        document.getElementById('error').style.backgroundColor = '#fff3cd';
                                        document.getElementById('error').style.color = '#856404';
                                        document.getElementById('error').style.borderColor = '#ffeeba';
                                    }

                                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªç©å®¶çš„æ•°æ®
                                    const firstUuid = Object.keys(allPlayersStats)[0];
                                    showPlayerStats(firstUuid);
                                }
                            }
                        }
                    })
                    .catch(function(error) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').textContent = `Failed to parse ZIP file: ${error.message}`;
                        document.getElementById('error').style.display = 'block';
                    });
            };
            reader.readAsArrayBuffer(file);
        }

        // æ·»åŠ æ›´æ–°ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†çš„å‡½æ•°
        function updatePlayerSelect() {
    console.log('updatePlayerSelectè¢«è°ƒç”¨');
    let playerSelect = document.getElementById('playerSelect');
    
    // å¦‚æœç©å®¶é€‰æ‹©å·²å­˜åœ¨ï¼Œå…ˆç§»é™¤å®ƒ
    if (playerSelect) {
        playerSelect.parentNode.remove();
    }
    
    // åˆ›å»ºæ–°çš„ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
    const searchContainer = document.getElementById('playerSearchContainer');
    const filterGroup = document.createElement('div');
    filterGroup.className = 'filter-group';
    filterGroup.innerHTML = `
        <label for="playerSelect" class="filter-label">Playerï¼š</label>
        <select id="playerSelect" class="category-filter">
        </select>
    `;
    
    // ç¡®ä¿æ’å…¥ä½ç½®æ­£ç¡®
    if (searchContainer) {
        // å°†ç©å®¶é€‰æ‹©æ’å…¥åˆ°æœç´¢æ¡†åé¢
        searchContainer.insertAdjacentElement('afterend', filterGroup);
        playerSelect = document.getElementById('playerSelect');

        playerSelect.addEventListener('change', function() {
            const selectedUuid = this.value;
            if (selectedUuid) {
                showPlayerStats(selectedUuid);
            }
        });
    } else {
        console.error('æœç´¢å®¹å™¨æœªæ‰¾åˆ°ï¼Œæ— æ³•åˆ›å»ºç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†');
    }

    // å¡«å……ç©å®¶é€‰é¡¹
    if (playerSelect) {
        playerSelect.innerHTML = '';
        Object.keys(allPlayersStats).forEach(uuid => {
            const playerName = getPlayerName(uuid);
            const option = document.createElement('option');
            option.value = uuid;
            option.textContent = `${playerName} (${uuidToFilename[uuid]})`;
            playerSelect.appendChild(option);
        });
    }
}

        // æ·»åŠ æ˜¾ç¤ºç©å®¶ç»Ÿè®¡æ•°æ®çš„å‡½æ•°
        function showPlayerStats(uuid) {
            const processedData = allPlayersStats[uuid];
            if (processedData) {
                const playerName = getPlayerName(uuid);
                const tableContainer = document.getElementById('tableContainer');
                tableContainer.innerHTML = `<h2>ç©å®¶: ${playerName}</h2>`;
                displayAsTable(processedData);
            }
        }


        // æ·»åŠ å¤„ç†usercache.jsonæ–‡ä»¶çš„å‡½æ•° - æ–°å¢
        function processUserCache(jsonData) {
            try {
                const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                if (Array.isArray(data)) {
                    data.forEach(user => {
                        if (user.uuid && user.name) {
                            // å­˜å‚¨UUIDåˆ°åç§°çš„æ˜ å°„
                            userCache[user.uuid] = user.name;
                        }
                    });
                    console.log('ç”¨æˆ·ç¼“å­˜æ•°æ®åŠ è½½æˆåŠŸ', userCache);
                    return true;
                }
                return false;
            } catch (error) {
                console.error('å¤„ç†ç”¨æˆ·ç¼“å­˜æ•°æ®æ—¶å‡ºé”™:', error);
                return false;
            }
        }

        // æ ¹æ®UUIDè·å–ç©å®¶åç§° - æ–°å¢
        function getPlayerName(uuid) {
            return userCache[uuid] || 'Unknow Player';
        }

        // åŠ è½½ç¿»è¯‘æ–‡ä»¶
        function loadTranslations() {
    // å¦‚æœå·²ç»ä¸Šä¼ äº†ç¿»è¯‘æ–‡ä»¶ï¼Œç›´æ¥è¿”å›
    if (translationFileUploaded) {
        console.log('ä½¿ç”¨å·²ä¸Šä¼ çš„ç¿»è¯‘æ–‡ä»¶');
        return Promise.resolve(translations);
    }

    // å°è¯•ä½¿ç”¨fetchåŠ è½½é»˜è®¤ç¿»è¯‘æ–‡ä»¶
    return fetch('translations.json')
        .then(response => {
            if (!response.ok) {
                throw new Error('ç¿»è¯‘æ–‡ä»¶åŠ è½½å¤±è´¥: ' + response.statusText);
            }
            return response.json();
        })
        .then(data => {
            translations = data;
            console.log('é»˜è®¤ç¿»è¯‘æ–‡ä»¶åŠ è½½æˆåŠŸ', translations);
            return translations;
        })
        .catch(error => {
            console.error('åŠ è½½é»˜è®¤ç¿»è¯‘æ–‡ä»¶æ—¶å‡ºé”™:', error);
            // ä½¿ç”¨é»˜è®¤ç¿»è¯‘
            return translations;
        });
}

        // å¤„ç† Minecraft ç»Ÿè®¡æ•°æ®
        function processMinecraftStats(jsonData) {
            try {
                const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                const stats = data.stats || {};
                const result = [];

                // éå†æ‰€æœ‰ç»Ÿè®¡ç±»åˆ«
                for (const [category, items] of Object.entries(stats)) {
                    // æå–ç±»åˆ«åç§°ï¼ˆç§»é™¤ 
                    const categoryName = category.replace('minecraft:', '');
                    // ç¿»è¯‘ç±»åˆ«åç§°
                    const translatedCategory = translations.category[categoryName] || categoryName;
        
                    // Iterate through all items in the category
                    for (const [item, count] of Object.entries(items)) {
                        // Extract item name (remove "minecraft:" prefix)
                        const itemName = item.replace('minecraft:', '');
                        // ç¿»è¯‘ç‰©å“åç§°
                        const translatedItem = translations.item[itemName] || itemName;
        
                        result.push({
                category: translatedCategory,
                originalCategory: categoryName, // æ–°å¢ï¼šä¿ç•™åŸå§‹ç±»åˆ«ID
                item: translatedItem,
                originalItem: itemName, // æ–°å¢ï¼šä¿ç•™åŸå§‹ç‰©å“ID
                count: count
            });
                    }
                }
        
                return result;
            } catch (error) {
                console.error('Error processing data:', error);
                return null;
            }
        }
        
        // åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadTranslations();
            // åˆå§‹åŒ–ç­›é€‰å™¨å¸ƒå±€
            initFiltersLayout();
        });
        
        // åˆå§‹åŒ–ç­›é€‰å™¨å¸ƒå±€
        function initFiltersLayout() {
            // ç¡®ä¿ç­›é€‰å™¨å®¹å™¨å¯è§
            const filtersContainer = document.getElementById('filters');
            if (filtersContainer) {
                filtersContainer.style.display = 'flex';
                // è°ƒç”¨updatePlayerSelectæ¥åˆ›å»ºç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
                updatePlayerSelect();
                // ç„¶åå¯ä»¥éšè—ç­›é€‰å™¨ï¼Œç›´åˆ°æœ‰æ•°æ®
                filtersContainer.style.display = 'none';
            }
        }

        // åœ¨æ–‡ä»¶åŠ è½½å®Œæˆåæ·»åŠ æœç´¢åŠŸèƒ½
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('playerSearch');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const searchTerm = this.value.toLowerCase();
                    const playerSelect = document.getElementById('playerSelect');
                    if (playerSelect) {
                        const options = playerSelect.options;
                        for (let i = 0; i < options.length; i++) {
                            const option = options[i];
                            const text = option.text.toLowerCase();
                            option.style.display = text.includes(searchTerm) ? '' : 'none';
                        }
                    }
                });
            } else {
                console.error('æœç´¢æ¡†å…ƒç´ æœªæ‰¾åˆ°');
            }
        });
        
        // ä¿®æ”¹displayAsTableå‡½æ•°ï¼Œæ·»åŠ å¯¼å‡ºæŒ‰é’®
        function displayAsTable(data) {
            const tableContainer = document.getElementById('tableContainer');
            const filtersContainer = document.getElementById('filters');
            const categoryFilter = document.getElementById('categoryFilter');
            const sortSelect = document.getElementById('sortSelect');
            
            // Clear container
            tableContainer.innerHTML = '';
            
            // Create table
            const table = document.createElement('table');
            table.className = 'stats-table';
            
            // Create table header
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th>Category</th>
                    <th>Item</th>
                    <th>Count</th>
                </tr>
            `;
            table.appendChild(thead);
            
            // Create table body
            const tbody = document.createElement('tbody');
            table.appendChild(tbody);
            
            // Function to render table with given data
            function renderTable(filteredData) {
                tbody.innerHTML = '';
                if (filteredData.length === 0) {
                    const emptyRow = document.createElement('tr');
                    emptyRow.innerHTML = '<td colspan="3" style="text-align: center;">No matching data</td>';
                    tbody.appendChild(emptyRow);
                    return;
                }
                
                filteredData.forEach(item => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td data-label="Category">${item.category}</td>
                <td data-label="Item" data-item-name="${item.item.toLowerCase()}">
                <button class="item-button" 
                        data-original-item="${item.originalItem}" 
                        data-original-category="${item.originalCategory}">
                    ${item.item}
                </button>
            </td>
                <td data-label="Count">${item.count.toLocaleString()}</td>
            `;
            tbody.appendChild(tr);
        });
        
        // æ·»åŠ ç‰©å“æŒ‰é’®ç‚¹å‡»äº‹ä»¶ç›‘å¬
            tbody.querySelectorAll('.item-button').forEach(button => {
                button.addEventListener('click', function() {
                    const originalItem = this.dataset.originalItem;
                    const originalCategory = this.dataset.originalCategory;
                    showItemRanking(originalItem, originalCategory);
                });
            });
            }
            
            // Function to sort data
            function sortData(dataToSort, sortType) {
                const sortedData = [...dataToSort];
                
                switch (sortType) {
                    case 'category':
                        return sortedData.sort((a, b) => a.category.localeCompare(b.category));
                    case 'count-asc':
                        return sortedData.sort((a, b) => a.count - b.count);
                    case 'count-desc':
                        return sortedData.sort((a, b) => b.count - a.count);
                    default:
                        return sortedData;
                }
            }
            
            // Initial render with sorted data
            let currentData = sortData(data, 'category');
            renderTable(currentData);
            
            // Add table to page
            tableContainer.appendChild(table);
            
            // Generate category filter options
            const categories = [...new Set(data.map(item => item.category))].sort();
            categoryFilter.innerHTML = '<option value="all">All Categories</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
            
            // Show filters
            filtersContainer.style.display = 'flex';
            
            // æ˜¾ç¤ºç‰©å“æœç´¢æ¡†
            const searchContainer = document.querySelector('.search-container');
            if (searchContainer) {
                searchContainer.style.display = 'block';
            }

            // Handle filter and sort changes
            function handleFilterAndSort() {
                const selectedCategory = categoryFilter.value;
                const sortType = sortSelect.value;
                
                // Filter data
                let filteredData = selectedCategory === 'all' 
                    ? data 
                    : data.filter(item => item.category === selectedCategory);
                
                // Sort data
                filteredData = sortData(filteredData, sortType);
                
                // Re-render table
                renderTable(filteredData);
            }
            
            // Add event listeners
            categoryFilter.addEventListener('change', handleFilterAndSort);
            sortSelect.addEventListener('change', handleFilterAndSort);
        }

        // Handle file upload - ä¿®æ”¹
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Show file name
            document.getElementById('fileInfo').textContent = `Selected: ${file.name}`;
            
            // Show loading state
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('tableContainer').innerHTML = '';
            document.getElementById('filters').style.display = 'none';

            // æ£€æŸ¥æ˜¯å¦ä¸ºZIPæ–‡ä»¶
            if (file.name.toLowerCase().endsWith('.zip')) {
                handleZipFile(file);
            } else if (file.name.toLowerCase() === 'usercache.json') {
                // å•ç‹¬å¤„ç†usercache.jsonæ–‡ä»¶
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        document.getElementById('loading').style.display = 'none';
                        const success = processUserCache(e.target.result);
                        if (success) {
                            document.getElementById('error').textContent = 'ç”¨æˆ·ç¼“å­˜æ•°æ®åŠ è½½æˆåŠŸï¼ç°åœ¨å¯ä»¥ä¸Šä¼ ç»Ÿè®¡æ•°æ®æ–‡ä»¶æˆ–ZIPå‹ç¼©åŒ…ã€‚';
                            document.getElementById('error').style.display = 'block';
                            document.getElementById('error').style.backgroundColor = '#d4edda';
                            document.getElementById('error').style.color = '#155724';
                            document.getElementById('error').style.borderColor = '#c3e6cb';
                            // å¦‚æœå·²æœ‰ç©å®¶æ•°æ®ï¼Œæ›´æ–°ç©å®¶åç§°
                            updatePlayerSelect();
                        } else {
                            document.getElementById('error').textContent = 'æ— æ³•è§£æusercache.jsonæ–‡ä»¶ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚';
                            document.getElementById('error').style.display = 'block';
                        }
                    } catch (error) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').textContent = `è§£ææ–‡ä»¶æ—¶å‡ºé”™: ${error.message}`;
                        document.getElementById('error').style.display = 'block';
                    }
                };
                reader.readAsText(file);
            } else {
                // å¤„ç†å•ä¸ªç»Ÿè®¡æ•°æ®æ–‡ä»¶
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        document.getElementById('loading').style.display = 'none';
                        // å¤„ç†æ™®é€šç»Ÿè®¡æ•°æ®æ–‡ä»¶
                        const processedData = processMinecraftStats(e.target.result);

                        if (processedData && processedData.length > 0) {
                            // å°è¯•ä»æ–‡ä»¶åæå–UUID
                            const fileName = file.name;
                            const uuidMatch = fileName.match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);
                            let playerName = 'æœªçŸ¥ç©å®¶';
                            let uuid = null;

                            if (uuidMatch && uuidMatch[1]) {
                                uuid = uuidMatch[1];
                                playerName = getPlayerName(uuid);
                                // å­˜å‚¨ç©å®¶æ•°æ®
                                allPlayersStats[uuid] = processedData;
                                uuidToFilename[uuid] = fileName;
                            }

                            // åœ¨è¡¨æ ¼ä¸Šæ–¹æ˜¾ç¤ºç©å®¶åç§°
                            const tableContainer = document.getElementById('tableContainer');
                            tableContainer.innerHTML = `<h2>ç©å®¶: ${playerName}</h2>`;

                            displayAsTable(processedData);
                            // æ›´æ–°ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
                            updatePlayerSelect();
                        } else {
                            document.getElementById('error').textContent = 'æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚';
                            document.getElementById('error').style.display = 'block';
                        }
                    } catch (error) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').textContent = `è§£ææ–‡ä»¶æ—¶å‡ºé”™: ${error.message}`;
                        document.getElementById('error').style.display = 'block';
                    }
                };
                reader.readAsText(file);
            }
        });

        // æ·»åŠ å¤„ç†ZIPæ–‡ä»¶çš„å‡½æ•°
        function handleZipFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                JSZip.loadAsync(e.target.result)
                    .then(function(zip) {
                        // å­˜å‚¨è§£æçš„æ–‡ä»¶æ•°
                        let processedFiles = 0;
                        let totalFiles = 0;
                        let hasUserCache = false;

                        // å…ˆæ£€æŸ¥æ–‡ä»¶æ€»æ•°
                        zip.forEach(function(relativePath, zipEntry) {
                            totalFiles++;
                        });

                        // éå†ZIPä¸­çš„æ‰€æœ‰æ–‡ä»¶
                        zip.forEach(function(relativePath, zipEntry) {
                            if (zipEntry.name.toLowerCase() === 'usercache.json') {
                                // å¤„ç†usercache.json
                                zipEntry.async('text')
                                    .then(function(content) {
                                        processUserCache(content);
                                        hasUserCache = true;
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    })
                                    .catch(function(error) {
                                        console.error('è¯»å–usercache.jsonå¤±è´¥:', error);
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    });
                            } else if (zipEntry.name.toLowerCase().endsWith('.json')) {
                                // å¤„ç†ç»Ÿè®¡æ•°æ®æ–‡ä»¶
                                zipEntry.async('text')
                                    .then(function(content) {
                                        const fileName = zipEntry.name;
                                        const uuidMatch = fileName.match(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);

                                        if (uuidMatch && uuidMatch[1]) {
                                            const uuid = uuidMatch[1];
                                            const processedData = processMinecraftStats(content);
                                            if (processedData && processedData.length > 0) {
                                                allPlayersStats[uuid] = processedData;
                                                uuidToFilename[uuid] = fileName;
                                            }
                                        }
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    })
                                    .catch(function(error) {
                                        console.error('è¯»å–JSONæ–‡ä»¶å¤±è´¥:', error);
                                        processedFiles++;
                                        checkIfAllFilesProcessed();
                                    });
                            } else {
                                processedFiles++;
                                checkIfAllFilesProcessed();
                            }
                        });

                        function checkIfAllFilesProcessed() {
                            if (processedFiles === totalFiles) {
                                document.getElementById('loading').style.display = 'none';
                                
                                if (Object.keys(allPlayersStats).length === 0) {
                                    document.getElementById('error').textContent = 'æœªæ‰¾åˆ°æœ‰æ•ˆçš„ç©å®¶ç»Ÿè®¡æ•°æ®æ–‡ä»¶ã€‚';
                                    document.getElementById('error').style.display = 'block';
                                } else {
                                    // æ›´æ–°ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
                                    updatePlayerSelect();

                                    if (hasUserCache) {
                                        document.getElementById('error').textContent = 'ZIP file parsed successfully! Loaded data for ' + Object.keys(allPlayersStats).length + ' players.';
                                        document.getElementById('error').style.display = 'block';
                                        document.getElementById('error').style.backgroundColor = '#d4edda';
                                        document.getElementById('error').style.color = '#155724';
                                        document.getElementById('error').style.borderColor = '#c3e6cb';
                                    } else {
                                        document.getElementById('error').textContent = 'ZIP file parsed successfully, but no usercache.json file found. Player names will be displayed as UUIDs.';
                                        document.getElementById('error').style.display = 'block';
                                        document.getElementById('error').style.backgroundColor = '#fff3cd';
                                        document.getElementById('error').style.color = '#856404';
                                        document.getElementById('error').style.borderColor = '#ffeeba';
                                    }

                                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªç©å®¶çš„æ•°æ®
                                    const firstUuid = Object.keys(allPlayersStats)[0];
                                    showPlayerStats(firstUuid);
                                }
                            }
                        }
                    })
                    .catch(function(error) {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').textContent = `Failed to parse ZIP file: ${error.message}`;
                        document.getElementById('error').style.display = 'block';
                    });
            };
            reader.readAsArrayBuffer(file);
        }

        // æ·»åŠ æ›´æ–°ç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†çš„å‡½æ•°
        function updatePlayerSelect() {
    console.log('updatePlayerSelectè¢«è°ƒç”¨');
    let playerSelect = document.getElementById('playerSelect');
    if (!playerSelect) {
        // åˆ›å»ºç©å®¶é€‰æ‹©ä¸‹æ‹‰æ¡†
        const searchContainer = document.getElementById('playerSearchContainer');
        const filterGroup = document.createElement('div');
        filterGroup.className = 'filter-group';
        filterGroup.innerHTML = `
            <label for="playerSelect" class="filter-label">Select Player:</label>
            <select id="playerSelect" class="category-filter">
            </select>
        `;
        searchContainer.insertAdjacentElement('afterend', filterGroup);
        playerSelect = document.getElementById('playerSelect');

        playerSelect.addEventListener('change', function() {
            const selectedUuid = this.value;
            if (selectedUuid) {
                showPlayerStats(selectedUuid);
            }
        });
    }

    // å¡«å……ç©å®¶é€‰é¡¹
    playerSelect.innerHTML = '';
    Object.keys(allPlayersStats).forEach(uuid => {
        const playerName = getPlayerName(uuid);
        const option = document.createElement('option');
        option.value = uuid;
        option.textContent = `${playerName} (${uuidToFilename[uuid]})`;
        playerSelect.appendChild(option);
    });
}

        // æ·»åŠ æ˜¾ç¤ºç©å®¶ç»Ÿè®¡æ•°æ®çš„å‡½æ•°
        function showPlayerStats(uuid) {
            const processedData = allPlayersStats[uuid];
            if (processedData) {
                const playerName = getPlayerName(uuid);
                const tableContainer = document.getElementById('tableContainer');
                tableContainer.innerHTML = `<h2>ç©å®¶: ${playerName}</h2>`;
                displayAsTable(processedData);
            }
        }
        
        // æ·»åŠ ç‰©å“æ’è¡Œæ¦œå¼¹çª—åŠŸèƒ½
        function showItemRanking(itemName, category) {
    // æ”¶é›†æ‰€æœ‰ç©å®¶çš„è¯¥é¡¹æ•°æ®
    const playerItemData = [];
    
    for (const [uuid, stats] of Object.entries(allPlayersStats)) {
        // æ ¹æ®ä¼ å…¥çš„ç±»åˆ«ç­›é€‰æ•°æ®
        const found = stats.find(item => 
            item.originalItem === itemName && 
            item.originalCategory === category
        );
        
        if (found) {
            playerItemData.push({
                uuid: uuid,
                playerName: getPlayerName(uuid),
                count: found.count
            });
        }
    }
    
    // æŒ‰æ•°é‡ä»å¤§åˆ°å°æ’åº
    playerItemData.sort((a, b) => b.count - a.count);
    
    // æ›´æ–°å¼¹çª—æ ‡é¢˜ï¼Œæ˜¾ç¤ºç±»åˆ«ä¿¡æ¯
    document.getElementById('modalTitle').textContent = `${itemName} (${category}) æ’è¡Œæ¦œ`;
            
            // ç”Ÿæˆæ’è¡Œæ¦œè¡¨æ ¼
            let rankingHtml = `
                <table class="ranking-table">
                    <tr>
                        <th>æ’å</th>
                        <th>ç©å®¶</th>
                        <th>æ•°é‡</th>
                    </tr>
            `;
            
            playerItemData.forEach((item, index) => {
                rankingHtml += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${item.playerName}</td>
                        <td>${item.count.toLocaleString()}</td>
                    </tr>
                `;
            });
            
            rankingHtml += `</table>`;
            document.getElementById('rankingContainer').innerHTML = rankingHtml;
            
            // æ˜¾ç¤ºå¼¹çª—
            const modal = document.getElementById('rankingModal');
            modal.classList.add('show');
        }
        
        // ç‚¹å‡»å¼¹çª—å¤–éƒ¨å…³é—­
        window.addEventListener('click', function(event) {
            const rankingModal = document.getElementById('rankingModal');
            const helpModal = document.getElementById('helpModal');
            const changelogModal = document.getElementById('changelogModal');
            
            if (event.target === rankingModal) {
                rankingModal.classList.remove('show');
            }
            
            if (event.target === helpModal) {
                helpModal.classList.remove('show');
            }
            
            if (event.target === changelogModal) {
                changelogModal.classList.remove('show');
            }
        });
    
        // ç¡®ä¿DOMåŠ è½½å®Œæˆåå†ç»‘å®šäº‹ä»¶
        document.addEventListener('DOMContentLoaded', function() {
            // å…³é—­æ’è¡Œæ¦œå¼¹çª—äº‹ä»¶
            const closeButton = document.querySelector('.close-button');
            if (closeButton) {
                closeButton.addEventListener('click', function() {
                    document.getElementById('rankingModal').classList.remove('show');
                });
            }
            
            // å…³é—­æ—¥å¿—å¼¹çª—äº‹ä»¶
            const closeButtonChangelog = document.querySelector('.close-button-changelog');
            if (closeButtonChangelog) {
                closeButtonChangelog.addEventListener('click', function() {
                    document.getElementById('changelogModal').classList.remove('show');
                });
            }
            
            // å¸®åŠ©æŒ‰é’®äº‹ä»¶
            const helpButton = document.getElementById('helpButton');
            if (helpButton) {
                helpButton.addEventListener('click', function() {
                    document.getElementById('helpModal').classList.add('show');
                });
            }
            
            // æ—¥å¿—æŒ‰é’®äº‹ä»¶
            const changelogButton = document.getElementById('changelogButton');
            if (changelogButton) {
                changelogButton.addEventListener('click', function() {
                    document.getElementById('changelogModal').classList.add('show');
                });
            }
            
            // å…³é—­æ•™ç¨‹å¼¹çª—äº‹ä»¶
            const closeButtonHelp = document.querySelector('.close-button-help');
            if (closeButtonHelp) {
                closeButtonHelp.addEventListener('click', function() {
                    document.getElementById('helpModal').classList.remove('show');
                });
            }
        });
    </script>
    
    <!-- ç‰©å“æ’è¡Œæ¦œå¼¹çª— -->
    <div id="rankingModal" class="modal">
        <div class="modal-content">
            <div class="modal-inner-content">
                <span class="close-button">&times;</span>
                <h2 id="modalTitle">ç‰©å“æ’è¡Œæ¦œ</h2>
                <div id="rankingContainer"></div>
            </div>
        </div>
    </div>
    <!-- æ•™ç¨‹æ¨¡æ€æ¡† -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-inner-content">
                <span class="close-button-help">&times;</span>
                <h2>Usage Tutorial</h2>
                <div id="helpContent">
                    <h3>Supported File Types</h3>
                    <p>This tool supports uploading the following types of files:</p>
                    
                    <h4>1. usercache.json</h4>
                    <p>This file contains the mapping between player UUIDs and player names, usually located in the <code>world</code> directory of the Minecraft server.</p>
                    <p><strong>Format Requirements:</strong></p>
                    <pre>[{"uuid": "Player UUID","name": "Player Name","expiresOn": "Expiration Time"}]</pre>
                    <p><strong>Upload Effect:</strong> After uploading, the tool can convert UUIDs to player names, making the statistics more readable.</p>
                    
                    <h4><a href="../translations.json" style="text-decoration: none;" target="_blank">2. translations.json (Click to view)</a></h4>
                    <p>The tool already comes with a translation package for vanilla items/blocks/actions. You don't need to upload this file if you don't have non-vanilla content. This file contains the translation mapping between item IDs and item names, used to convert in-game item IDs into readable names.</p>
                    <p><strong>Format Requirements:</strong></p>
    <pre>{
        "category": {
            "killed": "å‡»æ€",
            "killed_by": "è¢«å‡»æ€",
        },
        "item":{
            "acacia_boat": "é‡‘åˆæ¬¢æœ¨èˆ¹",
            "acacia_chest_boat": "é‡‘åˆæ¬¢æœ¨è¿è¾“èˆ¹",
            "allay_spawn_egg": "æ‚¦çµåˆ·æ€ªè›‹",
        }
    }</pre>
                    <p><strong>Upload Effect:</strong> After uploading, the tool will display items using translated names instead of original IDs.</p>
                    
                    <h4>3. Player Statistics File (.json)</h4>
                    <p>These files contain the game statistics of a single player and are usually located in the <code>world/stats</code> directory of the Minecraft server. The file name is typically in the format of the player's UUID.json.</p>
                    <p><strong>Upload Effect:</strong> After uploading, the tool will parse and display the player's detailed statistics, including data on mining, placing, killing, and more.</p>
                    
                    <h4>4. ZIP Archive</h4>
                    <p>You can package multiple statistics files into a ZIP format and upload them. The tool will automatically extract and process all valid files within it.</p>
                    
                    <h3>Usage Steps</h3>
                    <ol>
                        <li>Click the "Select File" button or drag and drop files into the upload area.</li>
                        <li>Choose the file(s) to upload (can be a single file or a ZIP archive).</li>
                        <li>Wait for the file parsing to complete.</li>
                        <li>Use the filters and search box on the page to view statistics.</li>
                        <li>Click on the item name in the table to view the player ranking for that item.</li>
                    </ol>
                    <h3>Additional Information</h3>
                    <ol>
                        <li>This page was generated by Trae_CN in conjunction with Doubao AI.</li>
                        <li>This page is supported by the Boring Minecraft Survival Electricity Server. Boring Minecraft is a harmonious and friendly community that supports both the international Java and Bedrock editions. There are no entry requirements, and all casual, survival electricity, and building players are welcome. Group ID: 897624943~</li>
                        <li>This page is hosted by Hot Iron Box.</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- æ—¥å¿—æ¨¡æ€æ¡† -->
    <div id="changelogModal" class="modal">
        <div class="modal-content">
            <div class="modal-inner-content">
                <span class="close-button-changelog">&times;</span>
                <h2>Bug Fix Log</h2>
                <div id="changelogContent">
                    <h3>2025072303_Search Box Bug Fix</h3>
                        <h4>Problem Description</h4>
                        <p>The search box is not working.</p>
                        <h4>Problem Cause</h4>
                        <p>This bug was introduced while fixing the previous bug.</p>
                    <h3>2025072302_Minecraft Sorting Bug Fix Log</h3>
                        <h4>Problem Description</h4>
                        <p>When switching players after sorting, the sorting effect is not retained.</p>
                        <h4>Solution</h4>
                        <p>Use the selected sorting method by default when switching players.</p>
                    <h3>2025072301_Minecraft Statistics Ranking Bug Fix Log</h3>
                        <h4>Problem Description</h4>
                        <p>When analyzing the server stats file, it was found that the zombie piglin kill data of the dummy player xekr was incorrectly displayed in the ranking: it should have shown <strong>6,917,927 zombie piglin kills</strong>, but actually showed <strong>1 death by zombie piglin</strong>.</p>
                        <h4>Problem Cause</h4>
                        <p>Through code analysis, it was found that the root cause of the problem lies in the confusion of two different statistical fields, <code>killed</code> and <code>killed_by</code>, in the statistical data processing logic:</p>
                        <ol>
                            <li>In the <code>processMinecraftStats</code> function, when parsing player data, the <code>minecraft:</code> prefix was removed and the translation table was used to convert IDs to display names, but the original statistical category IDs were not retained.</li>
                            <li>Due to the lack of original category identifiers, the ranking function cannot distinguish between two different statistical types: <code>killed</code> (active kills) and <code>killed_by</code> (deaths).</li>
                            <li>When clicking on an item to view the ranking, the translated name was used for matching by default, resulting in the incorrect display of death data instead of kill data.</li>
                        </ol>
                        <h4>Solution</h4>
                        <ol>
                            <li><strong>Optimize Data Processing Logic</strong>: Modify the <code>processMinecraftStats</code> function to add <code>originalCategory</code> and <code>originalItem</code> fields to the returned results to retain the original IDs.</li>
                            <li><strong>Fix Ranking Filtering Logic</strong>: Update the <code>showItemRanking</code> function to add the <code>originalCategory === 'killed'</code> condition to filter active kill data.</li>
                            <li><strong>Optimize UI Interaction</strong>: Modify the <code>renderTable</code> function to add <code>data-original-item</code> and <code>data-original-category</code> attributes to item buttons to store the original IDs.</li>
                        </ol>
                        <h4>Fix Effect</h4>
                        <p>After the fix, when clicking on the zombie piglin item to view the ranking, it will correctly show player xekr's 6,917,927 kills instead of the previously incorrectly displayed 1 death. Meanwhile, the system can correctly distinguish different statistical types to ensure accurate display of all players' statistical data.</p>
                </div>
            </div>
        </div>
    </div>

    <style>
        /* å¼¹çª—æ ·å¼ */
        .modal {
            visibility: hidden; /* æ›¿æ¢ display: none */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: rgba(0,0,0,0.4);
            opacity: 0;
            transition: visibility 0.3s ease, opacity 0.3s ease; /* æ·»åŠ  visibility è¿‡æ¸¡ */
        }

        .modal.show {
            visibility: visible; /* æ›¿æ¢ display: block */
            opacity: 1;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 3% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 900px;
            max-height: 85vh;
            overflow: hidden; /* ä¿æŒå¤–éƒ¨å®¹å™¨æº¢å‡ºéšè— */
            box-sizing: border-box;
            border-radius: 10px;
            transform: scale(0.9);
            transition: transform 0.3s ease;
            display: flex; /* æ·»åŠ flexå¸ƒå±€ */
            flex-direction: column; /* å‚ç›´æ’åˆ—å­å…ƒç´  */
        }

        /* ä¿®æ”¹å†…éƒ¨å®¹å™¨æ ·å¼ */
        .modal-inner-content {
            max-height: 70vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ä¸ºè§†å£é«˜åº¦çš„70% */
            overflow-y: auto; /* æ·»åŠ å‚ç›´æ»šåŠ¨æ¡ */
            padding: 20px;
        }

        /* ä¸ºå¼¹çª—å†…çš„æ ‡é¢˜å’Œæ®µè½æ·»åŠ é—´è· */
        .modal-inner-content h2 {
            margin-bottom: 20px;
        }

        .modal-inner-content h3 {
            margin-bottom: 15px;
            margin-top: 25px;
        }

        .modal-inner-content h4 {
            margin-bottom: 10px;
            margin-top: 20px;
        }

        .modal-inner-content p {
            margin-bottom: 15px;
        }

        .modal-inner-content ol,
        .modal-inner-content ul {
            margin-bottom: 15px;
            padding-left: 25px;
        }

        /* éšè—æ»šåŠ¨æ¡çš„æ ·å¼ä¿æŒä¸å˜ */
        /* ä¿®æ”¹æ»šåŠ¨æ¡æ ·å¼ - ç§»é™¤éšè—è®¾ç½®ï¼Œæ·»åŠ çª„æ»šåŠ¨æ¡å®šä¹‰ */
        .modal-inner-content::-webkit-scrollbar {
            width: 4px; /* çª„æ»šåŠ¨æ¡å®½åº¦ */
        }

        .modal-inner-content::-webkit-scrollbar-track {
            background: #f1f1f1; /* æ»šåŠ¨æ¡è½¨é“èƒŒæ™¯ */
            border-radius: 2px;
        }

        .modal-inner-content::-webkit-scrollbar-thumb {
            background: #888; /* æ»šåŠ¨æ¡æ»‘å—é¢œè‰² */
            border-radius: 2px;
        }

        .modal-inner-content::-webkit-scrollbar-thumb:hover {
            background: #555; /* æ»šåŠ¨æ¡æ»‘å—æ‚¬åœé¢œè‰² */
        }

        .modal-inner-content {
            scrollbar-width: thin; /* Firefox çª„æ»šåŠ¨æ¡ */
            scrollbar-color: #888 #f1f1f1; /* Firefox æ»‘å—å’Œè½¨é“é¢œè‰² */
        }

        .modal.show .modal-content {
            transform: scale(1);
        }
        
        .close-button, .close-button-help, .close-button-changelog {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-button:hover, .close-button-help:hover, .close-button-changelog:hover {
            color: black;
        }
        
        .ranking-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .ranking-table th, .ranking-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .ranking-table th {
            background-color: #f2f2f2;
        }
        
        .item-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 2px 1px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        /* æ•™ç¨‹å†…å®¹æ ·å¼ */
        #helpContent h3 {
            margin-top: 20px;
            color: #333;
        }
        
        #helpContent h4 {
            margin-top: 15px;
            color: #555;
        }
        
        #helpContent p {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        #helpContent pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        #helpContent code {
            font-family: monospace;
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        #helpContent ol {
            margin-left: 20px;
            margin-top: 10px;
        }
        
        #helpContent li {
            margin-bottom: 5px;
        }
        
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        /* Firefoxæµè§ˆå™¨æ»šåŠ¨æ¡æ ·å¼ */
        * {
            scrollbar-width: thin; /* ç»†æ»šåŠ¨æ¡ */
            scrollbar-color: #888 #f1f1f1; /* æ»‘å—é¢œè‰² è½¨é“é¢œè‰² */
        }
        
        .modal-content {
            scrollbar-width: auto; /* å¼¹çª—ä½¿ç”¨è‡ªåŠ¨å®½åº¦ï¼ˆä»ä¼šæ¯”é»˜è®¤ç»†ï¼‰ */
        }
        
        ::-webkit-scrollbar {
            width: 6px;  /* å‚ç›´æ»šåŠ¨æ¡å®½åº¦ */
            height: 6px; /* æ°´å¹³æ»šåŠ¨æ¡é«˜åº¦ */
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1; /* æ»šåŠ¨æ¡è½¨é“èƒŒæ™¯è‰² */
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888; /* æ»šåŠ¨æ¡æ»‘å—é¢œè‰² */
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555; /* æ»šåŠ¨æ¡æ»‘å—æ‚¬åœé¢œè‰² */
        }
        
        /* å¼¹çª—å†…å®¹åŒºåŸŸæ»šåŠ¨æ¡æ ·å¼ */
        .modal-content::-webkit-scrollbar {
            width: 4px;  /* å¼¹çª—å‚ç›´æ»šåŠ¨æ¡æ›´ç»† */
        }
    </style>
    
    <!-- æ·»åŠ åº•éƒ¨è¶…é“¾æ¥é•¿æ¡ -->
    <div style="background-color: #f1f1f1; padding: 10px 0; text-align: center; position: fixed; bottom: 0; width: 100%; z-index: 999;">
        <a href="https://mffyg.lanzoum.com/iO06H31hlykh" target="_blank" style="margin: 0 15px; color: #333; text-decoration: none;">Example Zipfile</a> |
        <a href="https://www.kdocs.cn/l/cgGYMvid44Fv" target="_blank" style="margin: 0 15px; color: #333; text-decoration: none;">Boring Minecraft Server</a>
    </div>
</body>
</html>
